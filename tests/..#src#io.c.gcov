        -:    0:Source:../src/io.c
        -:    0:Graph:/home/cdorner/haigo/tests/check_io-io.gcno
        -:    0:Data:/home/cdorner/haigo/tests/check_io-io.gcda
        -:    0:Runs:19
        -:    0:Programs:1
        -:    1:#include <stdlib.h>
        -:    2:#include <stdio.h>
        -:    3:#include <string.h>
        -:    4:#include <stdbool.h>
        -:    5:#include <ctype.h>
        -:    6:#include "global_const.h"
        -:    7:#include "io.h"
        -:    8:#include "global_tools.h"
        -:    9:
        -:   10:char command_input_buffer[SIZE_INPUT_BUFFER];
        -:   11:
        -:   12:bool input_empty    = false;
        -:   13:bool output_error   = false;
        -:   14:char output[MAX_OUTPUT_LENGTH];
        -:   15:
        -:   16:
        -:   17:/*******************************************************************/
        -:   18:/*  Usage     : read_gtp_input()                                   */
        -:   19:/*  Purpose   : Reads a GTP command from STDIN.                    */
        -:   20:/*  Parameter : Pointer to command struct                          */
        -:   21:/*  Returns   : Nothing                                            */
        -:   22:/*  Throws    : Nothing                                            */
        -:   23:/*  Comment   : Compare with "gnugo --mode gtp"                    */
        -:   24:/*            : Input larger than SIZE_INPUT_BUFFER is simply      */
        -:   25:/*            : ignored.                                           */
        -:   26:/*  See also  : http://www.lysator.liu.se/~gunnar/gtp/             */
        -:   27:/*******************************************************************/
        -:   28:
        -:   29:/**
        -:   30: *  @brief Read GTP command from STDIN.
        -:   31: *
        -:   32: *  Reads a GTP command from STDIN. Input which is larger than
        -:   33: *  SIZE_INPUT_BUFFER is simply ignored. The behaviour \e should be the same as
        -:   34: *  with "gnugo --mode gtp".
        -:   35: *
        -:   36: *  @param[in]  *command_data  Pointer to struct command
        -:   37: *  @return     nothing
        -:   38: *  @sa         <a href=@link3>GTP version 2.0</a>
        -:   39: */
function read_gtp_input called 0 returned 0% blocks executed 0%
    #####:   40:void read_gtp_input( struct command *command_data )
        -:   41:{
    #####:   42:    int c = '\n';
    #####:   43:    int i = 0;
        -:   44:    char tokens[MAX_TOKEN_COUNT][MAX_TOKEN_LENGTH];
        -:   45:
    #####:   46:    init_tokens(tokens);
    $$$$$:   46-block  0
call    0 never executed
        -:   47:
    #####:   48:    input_empty  = false;
    #####:   49:    output_error = false;
        -:   50:
        -:   51:    do {
    #####:   52:        c = getchar();
    $$$$$:   52-block  0
call    0 never executed
    #####:   53:        command_input_buffer[i] = (char) c;
    #####:   54:        i++;
    #####:   55:    } while ( c != '\n' && i < SIZE_INPUT_BUFFER );
branch  0 never executed
branch  1 never executed
    $$$$$:   55-block  0
branch  2 never executed
branch  3 never executed
        -:   56:
        -:   57:    // Overwrite last char with newline
    #####:   58:    command_input_buffer[i-1] = '\0';
        -:   59:
    #####:   60:    drop_comment(command_input_buffer);
    $$$$$:   60-block  0
call    0 never executed
    #####:   61:    trim(command_input_buffer);
call    0 never executed
        -:   62:
    #####:   63:    if ( strlen(command_input_buffer) == 0 ) {
branch  0 never executed
branch  1 never executed
    #####:   64:        input_empty = true;
    #####:   65:        return;
    $$$$$:   65-block  0
        -:   66:    }
        -:   67:
    #####:   68:    parse_gtp_input( command_input_buffer, tokens );
    $$$$$:   68-block  0
call    0 never executed
    #####:   69:    identify_tokens( tokens, command_data );
call    0 never executed
        -:   70:
    #####:   71:    return;
    $$$$$:   71-block  0
        -:   72:}
        -:   73:
        -:   74:/*******************************************************************/
        -:   75:/*  Usage     : set_output_error()                                 */
        -:   76:/*  Purpose   : Sets the variable output_error to true             */
        -:   77:/*  Parameter : None                                               */
        -:   78:/*  Returns   : Nothing                                            */
        -:   79:/*  Throws    : Nothing                                            */
        -:   80:/*  Comment   : This function should be called if the output is    */
        -:   81:/*            : considered an error.                               */
        -:   82:/*  See also  : [n/a]                                              */
        -:   83:/*******************************************************************/
function set_output_error called 0 returned 0% blocks executed 0%
    #####:   84:void set_output_error(void) {
        -:   85:
    #####:   86:    output_error = true;
    $$$$$:   86-block  0
        -:   87:
        -:   88:    return;
        -:   89:}
        -:   90:
        -:   91:/*******************************************************************/
        -:   92:/*  Usage     : get_output_error()                                 */
        -:   93:/*  Purpose   : Rteurns the state of output_error (true|false)     */
        -:   94:/*  Parameter : None                                               */
        -:   95:/*  Returns   : true|false                                         */
        -:   96:/*  Throws    : Nothing                                            */
        -:   97:/*  Comment   :                                                    */
        -:   98:/*  See also  : [n/a]                                              */
        -:   99:/*******************************************************************/
function get_output_error called 0 returned 0% blocks executed 0%
    #####:  100:bool get_output_error(void) {
        -:  101:
    #####:  102:    return output_error;
    $$$$$:  102-block  0
        -:  103:}
        -:  104:
        -:  105:/*******************************************************************/
        -:  106:/*  Usage     : add_output()                                       */
        -:  107:/*  Purpose   : Adds the given string to the output variable       */
        -:  108:/*  Parameter : String                                             */
        -:  109:/*  Returns   : Nothing                                            */
        -:  110:/*  Throws    : Nothing                                            */
        -:  111:/*  Comment   : Only complete lines must be given to this          */
        -:  112:/*            : function. A new line is appended automatically.    */
        -:  113:/*  See also  : [n/a]                                              */
        -:  114:/*******************************************************************/
function add_output called 0 returned 0% blocks executed 0%
    #####:  115:void add_output( const char to_output[] ) {
        -:  116:
    #####:  117:    int new_output_length
    #####:  118:        = (int)( strlen(output) + strlen(to_output) + 1 );
    #####:  119:    if ( new_output_length > MAX_OUTPUT_LENGTH ) {
    $$$$$:  119-block  0
branch  0 never executed
branch  1 never executed
    #####:  120:        fprintf( stderr, "MAX_OUTPUT_LENGTH exceeded\n" );
    $$$$$:  120-block  0
call    0 never executed
    #####:  121:        exit(EXIT_FAILURE);
call    0 never executed
        -:  122:    }
        -:  123:
    #####:  124:    strcat( output, to_output );
    #####:  125:    strcat( output, "\n" );
    $$$$$:  125-block  0
        -:  126:
        -:  127:    return;
        -:  128:}
        -:  129:
        -:  130:
        -:  131:/*******************************************************************/
        -:  132:/*  Usage     : print_output()                                     */
        -:  133:/*  Purpose   : Prints the content of output to STDOUT.            */
        -:  134:/*  Parameter : Command ID                                         */
        -:  135:/*  Returns   : Nothing                                            */
        -:  136:/*  Throws    : Nothing                                            */
        -:  137:/*  Comment   :                                                    */
        -:  138:/*  See also  : [n/a]                                              */
        -:  139:/*******************************************************************/
function print_output called 0 returned 0% blocks executed 0%
    #####:  140:void print_output( int command_id ) {
        -:  141:
        -:  142:    /*
        -:  143:    if ( input_empty == true ) {
        -:  144:        input_empty = false;
        -:  145:        return;
        -:  146:    }
        -:  147:    */
        -:  148:
    #####:  149:    if ( output_error == false ) {
    $$$$$:  149-block  0
branch  0 never executed
branch  1 never executed
    #####:  150:        printf("=");
    $$$$$:  150-block  0
call    0 never executed
        -:  151:    }
        -:  152:    else {
    #####:  153:        printf("?");
    $$$$$:  153-block  0
call    0 never executed
        -:  154:    }
        -:  155:
    #####:  156:    if ( command_id >= 0 ) {
    $$$$$:  156-block  0
branch  0 never executed
branch  1 never executed
    #####:  157:        printf( "%d", command_id );
    $$$$$:  157-block  0
call    0 never executed
        -:  158:    }
        -:  159:
    #####:  160:    printf(" ");
    $$$$$:  160-block  0
call    0 never executed
        -:  161:    
        -:  162:    // If output is empty we fill it with an empty string to
        -:  163:    // get that additional newline:
    #####:  164:    if ( strlen(output) == 0 ) {
branch  0 never executed
branch  1 never executed
    #####:  165:        add_output("");
    $$$$$:  165-block  0
call    0 never executed
        -:  166:    }
        -:  167:
    #####:  168:    printf( "%s\n", output );
    $$$$$:  168-block  0
call    0 never executed
        -:  169:
    #####:  170:    my_strcpy( output, "", MAX_OUTPUT_LENGTH );
call    0 never executed
        -:  171:    //output_error = false;
        -:  172:
        -:  173:    return;
        -:  174:}
        -:  175:
        -:  176:/*******************************************************************/
        -:  177:/*  Usage     : trim()                                             */
        -:  178:/*  Purpose   : Trims string.                                      */
        -:  179:/*  Parameter : Input string                                       */
        -:  180:/*  Returns   : Trimmed string                                     */
        -:  181:/*  Throws    : Nothing                                            */
        -:  182:/*  Comment   : Whitespace at the beginning and end are dropped.   */
        -:  183:/*            : Two or more whitespaces are substituted by one     */
        -:  184:/*            : whitespace.                                        */
        -:  185:/*  See also  : [n/a]                                              */
        -:  186:/*******************************************************************/
function trim called 8 returned 100% blocks executed 100%
        8:  187:void trim( char * input ) {
        -:  188:    char temp_input[SIZE_INPUT_BUFFER];
        8:  189:    char current_char = '\0';
        8:  190:    char last_char    = '\0';
        8:  191:    int i = 0;
        8:  192:    int j = 0;
        -:  193:
     2056:  194:    for ( i = 0; i < SIZE_INPUT_BUFFER; i++ ) {
        8:  194-block  0
     2048:  194-block  1
     2056:  194-block  2
branch  0 taken 2048
branch  1 taken 8 (fallthrough)
     2048:  195:        current_char = input[i];
        -:  196:
        -:  197:        /* Skip leading whitespace */
     2048:  198:        if ( isspace(current_char) && j == 0 ) {
     2048:  198-block  0
call    0 returned 2048
branch  1 taken 35 (fallthrough)
branch  2 taken 2013
       35:  198-block  1
branch  3 taken 8 (fallthrough)
branch  4 taken 27
        8:  199:            continue;
        8:  199-block  0
        -:  200:        }
        -:  201:        
        -:  202:        /* Write only one whitespace */
     2040:  203:        if ( isspace(last_char) && !isspace(current_char) && current_char != '\0' ) {
     2040:  203-block  0
call    0 returned 2040
branch  1 taken 27 (fallthrough)
branch  2 taken 2013
       27:  203-block  1
call    3 returned 27
branch  4 taken 11 (fallthrough)
branch  5 taken 16
       11:  203-block  2
branch  6 taken 7 (fallthrough)
branch  7 taken 4
        7:  204:            temp_input[j] = ' ';
        7:  205:            j++;
        7:  205-block  0
        -:  206:        }
        -:  207:
        -:  208:        /* Write non-whitespace characters */
     2040:  209:        if ( ! isspace(current_char) ) {
     2040:  209-block  0
call    0 returned 2040
branch  1 taken 2013 (fallthrough)
branch  2 taken 27
     2013:  210:            temp_input[j] = current_char;
     2013:  211:            j++;
     2013:  211-block  0
        -:  212:        }
        -:  213:
     2040:  214:        last_char = current_char;
     2040:  214-block  0
        -:  215:    }
        -:  216:
        8:  217:    temp_input[j] = '\0';
        -:  218:
        8:  219:    strncpy( input, temp_input, SIZE_INPUT_BUFFER );
        8:  219-block  0
        -:  220:
        -:  221:    return;
        -:  222:}
        -:  223:
        -:  224:/*******************************************************************/
        -:  225:/*  Usage     : drop_comment()                                     */
        -:  226:/*  Purpose   : Drop trailing comment from input string.           */
        -:  227:/*  Parameter : Input string                                       */
        -:  228:/*  Returns   : String without trailing comment.                   */
        -:  229:/*  Throws    : Nothing                                            */
        -:  230:/*  Comment   : The comment character '#' is substituted with '\0' */
        -:  231:/*  See also  : [n/a]                                              */
        -:  232:/*******************************************************************/
function drop_comment called 3 returned 100% blocks executed 100%
        3:  233:void drop_comment( char * input ) {
        3:  234:    int i = 0;
        3:  235:    char current_char = '\0';
        -:  236:
       21:  237:    for ( i = 0; i < SIZE_INPUT_BUFFER; i++ ) {
        3:  237-block  0
       15:  237-block  1
       18:  237-block  2
branch  0 taken 18
branch  1 taken 0 (fallthrough)
        3:  237-block  3
       18:  238:        current_char = input[i];
       18:  239:        if ( current_char == '#' ) {
       18:  239-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 16
        2:  240:            input[i] = '\0';
        2:  241:            break;
        2:  241-block  0
        -:  242:        }
       16:  243:        if ( current_char == '\0' ) {
       16:  243-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 15
        1:  244:            break;
        1:  244-block  0
        -:  245:        }
        -:  246:    }
        -:  247:
        -:  248:    return;
        -:  249:}
        -:  250:
        -:  251:/*******************************************************************/
        -:  252:/*  Usage     : is_input_empty()                                   */
        -:  253:/*  Purpose   : Returns true if no input has been given.           */
        -:  254:/*  Parameter : None                                               */
        -:  255:/*  Returns   : true|false                                         */
        -:  256:/*  Throws    : Nothing                                            */
        -:  257:/*  Comment   :                                                    */
        -:  258:/*  See also  : [n/a]                                              */
        -:  259:/*******************************************************************/
function is_input_empty called 0 returned 0% blocks executed 0%
    #####:  260:bool is_input_empty(void) {
        -:  261:
    #####:  262:    return input_empty;
    $$$$$:  262-block  0
        -:  263:}
        -:  264:
        -:  265:/*******************************************************************/
        -:  266:/*  Usage     : parse_gtp_input()                                  */
        -:  267:/*  Purpose   : Parses the GTP input.                              */
        -:  268:/*  Parameter : Input string, command                              */
        -:  269:/*  Returns   : GTP command and optional arguments                 */
        -:  270:/*  Throws    : Nothing                                            */
        -:  271:/*  Comment   : The input has to go through drop_comment() and     */
        -:  272:/*            : trim() before being parsed.                        */
        -:  273:/*  See also  : [n/a]                                              */
        -:  274:/*******************************************************************/
function parse_gtp_input called 0 returned 0% blocks executed 0%
    #####:  275:void parse_gtp_input( char * command_input_buffer, char tokens[][MAX_TOKEN_LENGTH] ) {
    #####:  276:    char current_char = '\0';
    #####:  277:    int i = 0;  // Index of input buffer
    #####:  278:    int j = 0;  // Counts number of tokens
    #####:  279:    int k = 0;  // Index of each token
        -:  280:
        -:  281:    // Get tokens from input:
    #####:  282:    for ( i = 0; i < SIZE_INPUT_BUFFER; i++ ) {
    $$$$$:  282-block  0
    $$$$$:  282-block  1
    $$$$$:  282-block  2
branch  0 never executed
branch  1 never executed
    #####:  283:        current_char = command_input_buffer[i];
    #####:  284:        if ( ! isspace(current_char) && current_char != '\0' ) {
    $$$$$:  284-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:  284-block  1
branch  3 never executed
branch  4 never executed
    #####:  285:            if ( k < MAX_TOKEN_LENGTH ) {
    $$$$$:  285-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  285-block  1
    #####:  286:                tokens[j][k] = current_char;
    #####:  287:                k++;
        -:  288:            }
        -:  289:            else {
    #####:  290:                set_output_error();
    $$$$$:  290-block  0
call    0 never executed
    #####:  291:                add_output( "MAX_TOKEN_LENGTH exceeded" );
call    0 never executed
    #####:  292:                init_tokens(tokens);
call    0 never executed
    #####:  293:                return;
        -:  294:            }
        -:  295:        }
        -:  296:        else {
    #####:  297:            tokens[j][k] = '\0';
    #####:  298:            j++;
    #####:  299:            k = 0;
        -:  300:
    #####:  301:            if ( j >= MAX_TOKEN_COUNT ) {
    $$$$$:  301-block  0
branch  0 never executed
branch  1 never executed
    #####:  302:                set_output_error();
    $$$$$:  302-block  0
call    0 never executed
    #####:  303:                add_output( "MAX_TOKEN_COUNT exceeded" );
call    0 never executed
    #####:  304:                init_tokens(tokens);
call    0 never executed
    #####:  305:                return;
        -:  306:            }
        -:  307:
        -:  308:            // Set terminating argument:
    #####:  309:            tokens[j][0] = '\0';
    $$$$$:  309-block  0
        -:  310:        }
        -:  311:
    #####:  312:        if ( current_char == '\0' ) {
    $$$$$:  312-block  0
branch  0 never executed
branch  1 never executed
    #####:  313:            break;
    $$$$$:  313-block  0
        -:  314:        }
        -:  315:    }
        -:  316:
    #####:  317:    return;
    $$$$$:  317-block  0
    $$$$$:  317-block  1
        -:  318:}
        -:  319:
        -:  320:/*******************************************************************/
        -:  321:/*  Usage     : init_tokens()                                      */
        -:  322:/*  Purpose   : Sets all token data strings to '\0'                */
        -:  323:/*  Parameter : None                                               */
        -:  324:/*  Returns   : Nothing                                            */
        -:  325:/*  Throws    : Nothing                                            */
        -:  326:/*  Comment   : None                                               */
        -:  327:/*  See also  : [n/a]                                              */
        -:  328:/*******************************************************************/
function init_tokens called 7 returned 100% blocks executed 100%
        7:  329:void init_tokens( char tokens[][MAX_TOKEN_LENGTH] ) {
        -:  330:    int i;
        -:  331:
       77:  332:    for ( i = 0; i < MAX_TOKEN_COUNT; i++ ) {
        7:  332-block  0
       70:  332-block  1
       77:  332-block  2
branch  0 taken 70
branch  1 taken 7 (fallthrough)
        7:  332-block  3
       70:  333:        tokens[i][0] = '\0';
        -:  334:    }
        -:  335:
        -:  336:    return;
        -:  337:}
        -:  338:
        -:  339:/*******************************************************************/
        -:  340:/*  Usage     : identify_tokens()                                  */
        -:  341:/*  Purpose   : Tries to identify the different parts of the       */
        -:  342:/*            : tokens array: id, command name, arguments          */
        -:  343:/*  Parameter : Tokens array, Pointer to struct command            */
        -:  344:/*  Returns   : Nothing                                            */
        -:  345:/*  Throws    : Nothing                                            */
        -:  346:/*  Comment   : This function moves the data from the tokens array */
        -:  347:/*            : to the command struct.                             */
        -:  348:/*  See also  : [n/a]                                              */
        -:  349:/*******************************************************************/
function identify_tokens called 6 returned 100% blocks executed 80%
        6:  350:void identify_tokens( char tokens[][MAX_TOKEN_LENGTH], struct command *command_data ) {
        -:  351:    int id;
        -:  352:    int arg_start;  // Index of first argument
        -:  353:    int i, j;
        -:  354:
        -:  355:    // Check if first token is regular id,
        -:  356:    // if not it must be the command name.
        6:  357:    id = atoi( tokens[0] );
        6:  357-block  0
call    0 returned 6
        6:  358:    if ( id > 0 ) {
branch  0 taken 3 (fallthrough)
branch  1 taken 3
        3:  359:        command_data->id = id;
        3:  360:        my_strcpy( command_data->name, tokens[1], MAX_TOKEN_LENGTH );
        3:  360-block  0
call    0 returned 3
        3:  361:        arg_start = 2;
        -:  362:    }
        3:  363:    else if ( id < 0 ) {
        3:  363-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  364:        command_data->id = -1;
    #####:  365:        my_strcpy( command_data->name, tokens[1], MAX_TOKEN_LENGTH );
    $$$$$:  365-block  0
call    0 never executed
    #####:  366:        arg_start = 2;
        -:  367:    }
        -:  368:    else {
        3:  369:        command_data->id = -1;
        3:  370:        my_strcpy( command_data->name, tokens[0], MAX_TOKEN_LENGTH );
        3:  370-block  0
call    0 returned 3
        3:  371:        arg_start = 1;
        -:  372:    }
        -:  373:
        -:  374:    // Check for special case id 0:
        6:  375:    if ( strcmp( tokens[0], "0" ) == 0 ) {
        6:  375-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####:  376:        command_data->id = 0;
    #####:  377:        my_strcpy( command_data->name, tokens[1], MAX_TOKEN_LENGTH );
    $$$$$:  377-block  0
call    0 never executed
    #####:  378:        arg_start = 2;
        -:  379:    }
        -:  380:
        -:  381:    // Copy arguments into command struct:
        6:  382:    j = 0;
       14:  383:    for ( i = arg_start; i < MAX_TOKEN_COUNT; i++ ) {
        6:  383-block  0
       14:  383-block  1
branch  0 taken 14
branch  1 taken 0 (fallthrough)
       14:  384:        if ( tokens[i][0] == '\0' ) {
       14:  384-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 8
        6:  385:            break;
        6:  385-block  0
        -:  386:        }
        8:  387:        my_strcpy( command_data->gtp_argv[j], tokens[i], MAX_TOKEN_LENGTH );
        8:  387-block  0
call    0 returned 8
        8:  388:        j++;
        -:  389:    }
        6:  390:    command_data->gtp_argc = j;
        -:  391:
        -:  392:    // Add terminating argument:
        6:  393:    my_strcpy( command_data->gtp_argv[j], "\0", MAX_TOKEN_LENGTH );
        6:  393-block  0
call    0 returned 6
        -:  394:
        -:  395:    // DEBUG
        -:  396:    /*
        -:  397:    printf( "ID: %d\n", command_data->id );
        -:  398:    printf( "NAME: %s\n", command_data->name );
        -:  399:    printf( "ARGC: %d\n", command_data->argc );
        -:  400:    for ( i = 0; i < j; i++ ) {
        -:  401:        printf( "ARG %d: %s\n", i, command_data->argv[i] );
        -:  402:    }
        -:  403:    */
        -:  404:
        -:  405:    return;
        -:  406:}
